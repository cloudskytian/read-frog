import type { SubtitlesFragment } from '@/utils/subtitles/types'
import { getLocalConfig } from '@/utils/config/storage'
import { PROCESS_LOOK_AHEAD_MS } from '@/utils/constants/subtitles'
import { aiSegmentBlock } from '@/utils/subtitles/processor/ai-segmentation'
import { optimizeSubtitles } from '@/utils/subtitles/processor/optimizer'

export class SegmentationPipeline {
  // Segmented results, read by translation pipeline
  processedFragments: SubtitlesFragment[] = []

  private rawFragments: SubtitlesFragment[]
  private segmentedRawStarts = new Set<number>()
  private aiSegmentFailedRawStarts = new Set<number>()
  private running = false
  private stopped = false

  private getVideoElement: () => HTMLVideoElement | null
  private getSourceLanguage: () => string

  constructor(options: {
    rawFragments: SubtitlesFragment[]
    getVideoElement: () => HTMLVideoElement | null
    getSourceLanguage: () => string
  }) {
    this.rawFragments = options.rawFragments
    this.getVideoElement = options.getVideoElement
    this.getSourceLanguage = options.getSourceLanguage
  }

  get isRunning(): boolean {
    return this.running
  }

  hasUnprocessedChunks(): boolean {
    return this.rawFragments.some(f => !this.segmentedRawStarts.has(f.start))
  }

  start() {
    this.stopped = false
    void this.runLoop()
  }

  stop() {
    this.stopped = true
  }

  restart() {
    void this.runLoop()
  }

  clearFailedStarts() {
    for (const start of this.aiSegmentFailedRawStarts) {
      this.segmentedRawStarts.delete(start)
    }
    this.aiSegmentFailedRawStarts.clear()
  }

  private async runLoop() {
    if (this.running)
      return
    this.running = true

    const video = this.getVideoElement()
    if (!video) {
      this.running = false
      return
    }

    try {
      while (!this.stopped && this.hasUnprocessedChunks()) {
        const didWork = await this.processNextChunk(video.currentTime * 1000)
        if (!didWork)
          break
      }
    }
    finally {
      this.running = false
    }
  }

  private replaceChunkRange(chunkStart: number, chunkEnd: number, nextFragments: SubtitlesFragment[]) {
    this.processedFragments = this.processedFragments.filter(
      fragment => fragment.end <= chunkStart || fragment.start >= chunkEnd,
    )
    this.processedFragments.push(...nextFragments)
    this.normalizeProcessedTimeline()
  }

  private normalizeProcessedTimeline() {
    if (this.processedFragments.length === 0) {
      return
    }

    const sorted = this.processedFragments
      .map(fragment => ({ ...fragment }))
      .sort((a, b) => a.start - b.start)

    const normalized: SubtitlesFragment[] = []

    for (const fragment of sorted) {
      const current = {
        ...fragment,
        end: Math.max(fragment.end, fragment.start),
      }
      const previous = normalized[normalized.length - 1]

      if (previous && previous.end > current.start) {
        previous.end = Math.max(previous.start, current.start)
      }

      normalized.push(current)
    }

    this.processedFragments = normalized
  }

  private async processNextChunk(currentTimeMs: number): Promise<boolean> {
    const chunk = this.findNextChunk(currentTimeMs)
    if (chunk.length === 0)
      return false

    chunk.forEach(f => this.segmentedRawStarts.add(f.start))

    const chunkStart = chunk[0].start
    const chunkEnd = chunk[chunk.length - 1].end

    try {
      const config = await getLocalConfig()
      if (config) {
        const segmented = await aiSegmentBlock(chunk, config)
        this.replaceChunkRange(chunkStart, chunkEnd, segmented)
      }
    }
    catch {
      chunk.forEach(f => this.aiSegmentFailedRawStarts.add(f.start))
      const optimized = optimizeSubtitles(chunk, this.getSourceLanguage())
      this.replaceChunkRange(chunkStart, chunkEnd, optimized)
    }

    return true
  }

  private findNextChunk(currentTimeMs: number): SubtitlesFragment[] {
    const searchStart = Math.max(0, currentTimeMs - 10_000)
    const firstUnprocessed = this.rawFragments.find(
      f => f.start >= searchStart && !this.segmentedRawStarts.has(f.start),
    )
    if (!firstUnprocessed)
      return []

    const windowEnd = firstUnprocessed.start + PROCESS_LOOK_AHEAD_MS
    return this.rawFragments.filter(
      f => f.start >= firstUnprocessed.start && f.start < windowEnd
        && !this.segmentedRawStarts.has(f.start),
    )
  }
}
